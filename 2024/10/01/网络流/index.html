<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络流 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="12345678910111213141516171819202122232425262728293031321. 基本概念    1.1 流网络，不考虑反向边    1.2 可行流，不考虑反向边        1.2.1 两个条件：容量限制、流量守恒        1.2.2 可行流的流量指从源点流出的流量 - 流入源点的流量        1.2.3 最大流是指最大可行流    1.3 残留网">
<meta property="og:type" content="article">
<meta property="og:title" content="网络流">
<meta property="og:url" content="http://example.com/2024/10/01/%E7%BD%91%E7%BB%9C%E6%B5%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="12345678910111213141516171819202122232425262728293031321. 基本概念    1.1 流网络，不考虑反向边    1.2 可行流，不考虑反向边        1.2.1 两个条件：容量限制、流量守恒        1.2.2 可行流的流量指从源点流出的流量 - 流入源点的流量        1.2.3 最大流是指最大可行流    1.3 残留网">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-10-01T02:53:38.432Z">
<meta property="article:modified_time" content="2024-10-01T02:53:48.674Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/01/%E7%BD%91%E7%BB%9C%E6%B5%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络流',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-10-01 10:53:48'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">99</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-10-01T02:53:38.432Z" title="Created 2024-10-01 10:53:38">2024-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-10-01T02:53:48.674Z" title="Updated 2024-10-01 10:53:48">2024-10-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络流"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1. 基本概念</span><br><span class="line">    1.1 流网络，不考虑反向边</span><br><span class="line">    1.2 可行流，不考虑反向边</span><br><span class="line">        1.2.1 两个条件：容量限制、流量守恒</span><br><span class="line">        1.2.2 可行流的流量指从源点流出的流量 - 流入源点的流量</span><br><span class="line">        1.2.3 最大流是指最大可行流</span><br><span class="line">    1.3 残留网络，考虑反向边，残留网络的可行流f&#x27; + 原图的可行流f = 原题的另一个可行流</span><br><span class="line">        (1) |f&#x27; + f| = |f&#x27;| + |f|</span><br><span class="line">        (2) |f&#x27;| 可能是负数</span><br><span class="line">    1.4 增广路径</span><br><span class="line">    1.5 割</span><br><span class="line">        1.5.1 割的定义</span><br><span class="line">        1.5.2 割的容量，不考虑反向边，“最小割”是指容量最小的割。</span><br><span class="line">        1.5.3 割的流量，考虑反向边，f(S, T) &lt;= c(S, T)</span><br><span class="line">        1.5.4 对于任意可行流f，任意割[S, T]，|f| = f(S, T)</span><br><span class="line">        1.5.5 对于任意可行流f，任意割[S, T]，|f| &lt;= c(S, T)</span><br><span class="line">        1.5.6 最大流最小割定理</span><br><span class="line">            (1) 可行流f是最大流</span><br><span class="line">            (2) 可行流f的残留网络中不存在增广路</span><br><span class="line">            (3) 存在某个割[S, T]，|f| = c(S, T)</span><br><span class="line">    1.6. 算法</span><br><span class="line">        1.6.1 EK O(nm^2)</span><br><span class="line">        1.6.2 Dinic O(n^2m)</span><br><span class="line">    1.7 应用</span><br><span class="line">        1.7.1 二分图</span><br><span class="line">            (1) 二分图匹配</span><br><span class="line">            (2) 二分图多重匹配</span><br><span class="line">        1.7.2 上下界网络流</span><br><span class="line">            (1) 无源汇上下界可行流</span><br><span class="line">            (2) 有源汇上下界最大流</span><br><span class="line">            (3) 有源汇上下界最小流</span><br><span class="line">        1.7.3 多源汇最大流</span><br></pre></td></tr></table></figure>
<p>#基本概念<br>##流网络<br>定义:一个有边权的有向图 G&#x3D;{V,E,s,t,c} V是所有的点集,E是所有的边集,s是源点,t为汇点,c为边权<br>我们可以把流网络类比成下水道,每一条边都相当于一根水管,每一根水管都有一个容量,即边权,<br>源点即为入水口,汇点即为排水口,并且在流网络中,我们不考虑反向边.<br>下面给出一个流网络例子<br><img src="https://img2020.cnblogs.com/blog/2153725/202102/2153725-20210203111020009-621261084.png" width="25%" height="25%" /></p>
<p>##可行流<br>条件:流量守恒,容量限制.<br>对于每一个可行流,它在流网络中的每一条边的流量都不能大于容量限制,并且可行流的流量指源点流出的流量 - 流入源点的流量,最大流指的即是最大可行流<br>下面给出一个上面例子的一个可行流<br><img src="https://img2020.cnblogs.com/blog/2153725/202102/2153725-20210203111803326-2043355563.png" width="25%" height="25%" /><br>这个可行流的流量即为$|f|&#x3D;7$</p>
<p>##残留网络<br>残留网络是在可行流的基础上产生的,即每一个可行流对应一个残留网络,在残留网络中我们需要考虑反向边,<br>需要注意的是,残留网络也是一个流网络,那么它同样也满足流网络的定义,只不过需要考虑反向边,<br>我们定义该流网络中的边集为V,那么对于每一条残留网络的边它的容量<br>$c’(u,v)&#x3D;<br>\begin{cases} c(u,v)-f(u,v), (u,v)\in{V} \<br>   f(v,u),(v,u)\in{V}<br>\end{cases}$<br>对于残留网络中的可行流,记作f’<br>对于一个残留网络,我们有f’+f也是一个原流网络的可行流<br>对于证明,我们可以考虑可行流的两个条件<br>对于流量守恒,可以感性理解下,显然成立<br>对于容量限制,我们讨论同向与反向,对于同向,即两条边的流量相加,对于反向,即两条边的流量相减<br>那么考虑两种情况<br>$1^{。}$同向<br>$\because 0 \le  f’(u,v) \le c’(u,v)&#x3D;c(u,v)-f(u,v)$<br>$\therefore 0 \le f’(u,v)+f(u,v) \le c(u,v)$<br>成立<br>$2^{。}$反向<br>$\because 0 \le f’(u,v) \le c’(u,v)&#x3D;f(v,u) \le c(v,u)$<br>$\therefore 0 \le f’(u,v) - f(v,u) \le c(v,u)$<br>成立<br>那么就可以得到|f’+f|&#x3D;|f’|+|f|<br>##增广路径<br>对于一个可行流的残留网络,如果存在一条路径上所有的边的流量都大于0的s到t的路径,<br>那么我们就称这条路径为增广路径,很显然,如果有增广路径,那么这个可行流一定不是最大流<br>那如果一个可行流没有增广路径,能否说它一定是最大流?<br>这时候,我们就要引入割了<br>##割<br>对于一个流网络的点集V,我们将它分为S,T两个集合,其中S,T满足$s\in S,t \in T,S \cup T&#x3D;V,S \cap T &#x3D; \varnothing$<br><img src="https://img2020.cnblogs.com/blog/2153725/202102/2153725-20210203115108094-640950761.png"><br>这就是一个割,对于一个割的容量,我们定义为$c(S,T)&#x3D;\sum\limits_{u \in S} \sum\limits_{v \in T} c(u,v)$<br>割的流量,定义为$f(S,T)&#x3D;\sum\limits_{u \in S} \sum\limits_{v \in T} f(u,v)-\sum\limits_{v \in S} \sum\limits_{u \in T} c(v,u)$<br>那么我们可以得到$f(u,v)&#x3D;-f(v,u),f(x,y \cup z)&#x3D;f(x,z)+f(x,y),f(x,x)&#x3D;0,f(x \cup y,z)&#x3D;f(x,z)+f(y,z)$<br>证明|f|&#x3D;f(S,T)<br>$\because f(S,T)+f(S,S)&#x3D;f(S,V)$<br>$\therefore f(S,T)&#x3D;f(S,V)-f(S,S)&#x3D;f(S,V)&#x3D;f(s,V)+f(S-{s},V)$<br>令S’&#x3D;S-{s}<br>$\because f(S’,V)&#x3D; \sum\limits_{u \in S’} (\sum\limits_{v \in V} f(u,v)-\sum\limits_{v \in V} f(v,u))&#x3D;0$<br>$\therefore f(S,T)&#x3D;|f|$<br>得证<br>明显我们可以的到$f(S,T) \le \sum\limits_{u \in S} \sum\limits_{v \in T} c(u,v)-\sum\limits_{v \in S} \sum\limits_{u \in T} c(v,u) \le c(S,T)$<br>即$f(S,T) \le c(S,T)$<br>我们就可以得到最大流小于最小割<br>有了割我们可以干什么,接下来就有了最大流最小割定理<br>(1) 可行流f是最大流<br>(2) 可行流f的残留网络中不存在增广路<br>(3) 存在某个割(S,T)，|f| &#x3D; c(S, T)<br>其中知道任意一条,即可求出其他两条<br>证明<br>对于$(1)\Rightarrow (2)$<br>我们可以用反证法,假设f为最大流,若它存在增广路,则它一定不是最大流,矛盾.<br>故若f为最大流,那么它一定不存在增广路<br>对于$(3) \Rightarrow (1)$<br>$\because 最大流 \le c(S,T)$<br>又$\because |f|&#x3D;c(S,T)$<br>$\therefore 最大流 \le |f|$<br>又$\because |f| \le 最大流$<br>$\therefore |f|&#x3D;最大流$<br>对于$(2) \Rightarrow (3)$<br>我们假设S为残留网络从s出发,沿流量大于0的边走,能够到达的点击,T&#x3D;V-S<br><img src="https://img2020.cnblogs.com/blog/2153725/202102/2153725-20210203115108094-640950761.png"><br>对于一条从S流向T的边(x,y),则f(x,y)&#x3D;c(x,y),f(y,x)&#x3D;0<br>若f(x,y)&lt;c(x,y),那么在残留网络中,y就能被x遍历到,那么应该被划分到S中,故f(x,y)&#x3D;c(x,y)<br>若f(y,x)&gt;0,那么在残留网络中,就会有一条流量大于0的反向边使得y能被x遍历到,故f(y,x)&#x3D;0;<br>得证<br>那么我们就得到了一个结论,如果一个可行流的残留网络中没有增广路径,那么它就是最大流</p>
<p>##最大流<br>方法FF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while()</span><br><span class="line">找增广路</span><br><span class="line">更新残留网络</span><br></pre></td></tr></table></figure>
<p>实现FF的两种方法<br>EK求最大流$O(nm^2)$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1005, M = 2e4 + 5, INF = 1e9;</span><br><span class="line"></span><br><span class="line">int head[N], ver[M], c[M], net[M], f[M];</span><br><span class="line">int tot, pre[N], q[N], n, m, S, T, vis[N];</span><br><span class="line">    </span><br><span class="line">void add(int a, int b, int w)</span><br><span class="line">&#123;</span><br><span class="line">    ver[tot] = b, c[tot] = w, net[tot] = head[a], head[a] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int front = 0, tail = -1;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[S] = true, f[S] = INF, q[++tail] = S;</span><br><span class="line">    while (front &lt;= tail)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = q[front++];</span><br><span class="line">        for (int i = head[u]; i; i = net[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int v = ver[i];</span><br><span class="line">            if (!vis[v] &amp;&amp; c[i])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[v] = true;</span><br><span class="line">                f[v] = min(f[u], c[i]);</span><br><span class="line">                pre[v] = i;</span><br><span class="line">                if (v == T)</span><br><span class="line">                    return true;</span><br><span class="line">                q[++tail] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long EK()</span><br><span class="line">&#123;</span><br><span class="line">    long long res = 0;</span><br><span class="line">    while (bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        res += f[T];</span><br><span class="line">        for (int i = T; i != S; i = ver[pre[i] ^ 1])</span><br><span class="line">            c[pre[i]] -= f[T], c[pre[i] ^ 1] += f[T];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    while (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w), add(v, u, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;, EK());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dinic求最大流$O(n^2m)$<br>主要是对EK算法进行了一些优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e4 + 5, M = 2e5 + 5, INF = 1e9;</span><br><span class="line"></span><br><span class="line">int n, m, S, T;</span><br><span class="line">int head[N], net[M], cpt[M], ver[M],idx;</span><br><span class="line">int f[N], cur[N], d[N], q[N];</span><br><span class="line"></span><br><span class="line">void add(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">    net[idx] = head[a];</span><br><span class="line">    ver[idx] = b;</span><br><span class="line">    cpt[idx] = c;</span><br><span class="line">    head[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int front = 0, tail = 0;</span><br><span class="line">    memset(d, -1, sizeof(d));</span><br><span class="line">    q[0] = S, d[S] = 0, cur[S] = head[S];</span><br><span class="line">    while (front &lt;= tail)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = q[front++];</span><br><span class="line">        for (int i = head[u]; ~i; i = net[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int v = ver[i];</span><br><span class="line">            if (d[v] == -1 &amp;&amp; cpt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + 1;</span><br><span class="line">                f[v] = min(f[u], cpt[i]);</span><br><span class="line">                cur[v] = head[v];</span><br><span class="line">                if (v == T)</span><br><span class="line">                    return true;</span><br><span class="line">                q[++tail] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int u, int limit)</span><br><span class="line">&#123;</span><br><span class="line">    if (u == T)</span><br><span class="line">        return limit;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    for (int i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = net[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        int v = ver[i];</span><br><span class="line">        if (d[v] == d[u] + 1 &amp;&amp; cpt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int x = find(v, min(limit - flow, cpt[i]));</span><br><span class="line">            if (!x)</span><br><span class="line">                d[v] = -1;</span><br><span class="line">            cpt[i] -= x, cpt[i ^ 1] += x, flow += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dinic()</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0, flow;</span><br><span class="line">    while (bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        while (flow = find(S, INF))</span><br><span class="line">            res += flow;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    while (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w), add(v, u, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, dinic());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##应用<br>###二分图匹配<br>例题<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2756">P2756 飞行员配对方案问题</a><br>这道可用之前学过的O(nm)算法匈牙利算法过掉，但是我们现在可用$O(m \sqrt(n))$的网络流来做这道题<br>首先考虑如何建图,先把源点和汇点建出,然后把外籍飞行员和英国飞行员分为两块<br><img src="https://img2020.cnblogs.com/blog/2153725/202102/2153725-20210204171846524-1171052277.png" width="25%" height="25%" /><br>然后考虑如何连边,因为每个外籍飞行员只能连一个英国飞行员,所以考虑连给外籍飞行员与英国飞行员之间连一条容量为1的边,源点与汇点连向二分图的两部分,每条边的容量为1,<br>那么很明显,这是一个流网络,并且该流网络的最大流即为题目所求<br>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 105, M = 5205, INF = 1e8;</span><br><span class="line"></span><br><span class="line">int n, m, S, T;</span><br><span class="line">int head[N], ver[M], net[M], cpt[M], idx;</span><br><span class="line">int q[N], cur[N], d[N], f[N], front, tail;</span><br><span class="line"></span><br><span class="line">void add(int a, int b , int c)</span><br><span class="line">&#123;</span><br><span class="line">    net[idx] = head[a], ver[idx] = b, cpt[idx] = c, head[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    front = 0, tail = 0;</span><br><span class="line">    memset(d, -1, sizeof(d));</span><br><span class="line">    q[0] = S, d[S] = 0, cur[S] = head[S];</span><br><span class="line">    while (front &lt;= tail)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = q[front++];</span><br><span class="line">        for (int i = head[u]; ~i; i = net[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int v = ver[i];</span><br><span class="line">            if (d[v] == -1 &amp;&amp; cpt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + 1;</span><br><span class="line">                cur[v] = head[v];</span><br><span class="line">                if (v == T)</span><br><span class="line">                    return true;</span><br><span class="line">                q[++tail] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int u, int limit)</span><br><span class="line">&#123;</span><br><span class="line">    if (u == T)</span><br><span class="line">        return limit;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    for (int i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = net[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        int v = ver[i];</span><br><span class="line">        if (d[v] == d[u] + 1 &amp;&amp; cpt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int x = find(v, min(limit - flow, cpt[i]));</span><br><span class="line">            if (!x)</span><br><span class="line">                d[v] = -1;</span><br><span class="line">            cpt[i] -= x, cpt[i ^ 1] += x, flow += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dinic()</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0, flow;</span><br><span class="line">    while (bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        while (flow = find(S, INF))</span><br><span class="line">            res += flow; </span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    S = 0, T = n + 1;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">        add(S, i , 1), add(i, S ,0);</span><br><span class="line">    for (int i = m + 1; i &lt;= n; i++)</span><br><span class="line">        add(i, T, 1), add(T, i, 0);</span><br><span class="line">    int u, v;</span><br><span class="line">    while (scanf(&quot;%d %d&quot;, &amp;u, &amp;v) &amp;&amp; ~u &amp;&amp; ~v)</span><br><span class="line">    &#123;</span><br><span class="line">        add(u, v, 1), add(v, u, 0);        </span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, dinic());</span><br><span class="line">    for (int i = 0; i &lt; idx; i += 2)</span><br><span class="line">        if (!cpt[i] &amp;&amp; ver[i] &gt; m &amp;&amp; ver[i] &lt;= n)</span><br><span class="line">            printf(&quot;%d %d\n&quot;, ver[i ^ 1], ver[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###二分图多重匹配<br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3254">P3254 圆桌问题</a><br>这道题如果用匈牙利算法就做不出来了<br>建图方式与二分图匹配差不多,只不过边的容量有所改变而已</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 505, M = 2e5 + 5, INF = 1e8;</span><br><span class="line"></span><br><span class="line">int n, m, S, T;</span><br><span class="line">int head[N], ver[M], net[M], cpt[M], idx;</span><br><span class="line">int q[N], cur[N], d[N], R[N], C[N], ans[N][N];</span><br><span class="line"></span><br><span class="line">void add(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">    net[idx] = head[a], ver[idx] = b, cpt[idx] = c, head[a] = idx++;</span><br><span class="line">    net[idx] = head[b], ver[idx] = a, cpt[idx] = 0, head[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int front = 0, tail = 0;</span><br><span class="line">    memset(d, -1, sizeof(d));</span><br><span class="line">    q[0] = S, d[S] = 0, cur[S] = head[S];</span><br><span class="line">    while (front &lt;= tail)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = q[front++];</span><br><span class="line">        for (int i = head[u]; ~i; i = net[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int v = ver[i];</span><br><span class="line">            if (d[v] == -1 &amp;&amp; cpt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + 1;</span><br><span class="line">                cur[v] = head[v];</span><br><span class="line">                if (v == T)</span><br><span class="line">                    return true;</span><br><span class="line">                q[++tail] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int u, int limit)</span><br><span class="line">&#123;</span><br><span class="line">    if (u == T)</span><br><span class="line">        return limit;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    for (int i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = net[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        int v = ver[i];</span><br><span class="line">        if (d[v] == d[u] + 1 &amp;&amp; cpt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int x = find(v, min(limit - flow, cpt[i]));</span><br><span class="line">            if (!x)</span><br><span class="line">                d[v] = -1;</span><br><span class="line">            cpt[i] -= x, cpt[i ^ 1] += x, flow += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dinic()</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0, flow;</span><br><span class="line">    while (bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        while (flow = find(S, INF))</span><br><span class="line">            res += flow;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int flux = 0;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    S = 0, T = n + m + 1;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;R[i]);</span><br><span class="line">        add(S, i, R[i]), flux += R[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = m + 1; i &lt;= m + n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;C[i]);</span><br><span class="line">        add(i, T, C[i]);</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">            add(j, i, 1);            </span><br><span class="line">    &#125;</span><br><span class="line">    if (dinic() == flux)</span><br><span class="line">        printf(&quot;1\n&quot;);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;0&quot;);</span><br><span class="line">        return 0;        </span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; idx; i += 2)</span><br><span class="line">    &#123;</span><br><span class="line">        if (cpt[i ^ 1] &amp;&amp; ver[i] &gt; m &amp;&amp; ver[i] &lt;= m + n)</span><br><span class="line">            ans[ver[i ^ 1]][++ans[ver[i ^ 1]][0]] = ver[i] - m;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= ans[i][0]; j++)</span><br><span class="line">            printf(&quot;%d &quot;, ans[i][j]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>##无源汇上下界可行流<br>例题<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/2190/">2188. 无源汇上下界可行流</a><br>这道题与流网络的是,这道题没有给出源点汇点,并且每条边有一个下界,那么我们考虑将它转化为一个流网络<br>假设原图中的流量为$f(u,v)$,下界为$c_l(u,v)$,上界为$c_u(u,v)$<br>那么$c_l(u,v) \le f(u,v) \le c_u(u,v) \Rightarrow 0 \le f(u,v)-c_l(u,v) \le c_u(u,v)-c_l(u,v)$<br>$c’(u,v)&#x3D;c_u(u,v)-c_l(u,v)$即为转化后的容量限制<br>那么转化后是否满足流量守恒呢?<br>显然是不一定的<br>因为原图的流量是守恒的,并且对于每一个点,每一条入边与每一条出边所减去的$c_l$是不一样的,所以不能保证一定是相等的<br>那么该如何解决,我们设$c_{in},c_{out}$为该点所有的减去的容量<br>如何$c_{in}&gt;c_{out}$那么从源点连一条容量为$c_{in}-c_{out}$的边,小于0则连向汇点<br>那么可以知道,若原图存在一个可行流,那么就说明新图从S流出的边一定是流满了的<br>那么判断原图存不存在可行流只需要判断新图存不存在流满的情况即可<br>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 205, M = 20405, INF = 1e8;</span><br><span class="line"></span><br><span class="line">int n, m, S, T;</span><br><span class="line">int head[N], ver[M], net[M], cpt[M], idx;</span><br><span class="line">int q[N], cur[N], d[N], cm[M], in[N], out[N];</span><br><span class="line"></span><br><span class="line">void add(int a, int b, int up, int low)</span><br><span class="line">&#123;</span><br><span class="line">    net[idx] = head[a], ver[idx] = b, cpt[idx] = up - low, cm[idx] = low, head[a] = idx++;</span><br><span class="line">    net[idx] = head[b], ver[idx] = a, cpt[idx] = 0, cm[idx] = low, head[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int front = 0, tail = 0;</span><br><span class="line">    memset(d, -1, sizeof(d));</span><br><span class="line">    q[0] = S, d[S] = 0, cur[S] = head[S];</span><br><span class="line">    while (front &lt;= tail)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = q[front++];</span><br><span class="line">        for (int i = head[u]; ~i; i = net[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int v = ver[i];</span><br><span class="line">            if (d[v] == - 1 &amp;&amp; cpt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + 1;</span><br><span class="line">                cur[v] = head[v];</span><br><span class="line">                if (v == T)</span><br><span class="line">                    return true;</span><br><span class="line">                q[++tail] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int u, int limit)</span><br><span class="line">&#123;</span><br><span class="line">    if (u == T)</span><br><span class="line">        return limit;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    for (int i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = net[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        int v = ver[i];</span><br><span class="line">        if (d[v] == d[u] + 1 &amp;&amp; cpt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            int x = find(v, min(limit - flow, cpt[i]));</span><br><span class="line">            if (!x)</span><br><span class="line">                d[v] = -1;</span><br><span class="line">            cpt[i] -= x, cpt[i ^ 1] += x, flow += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dinic()</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0, flow;</span><br><span class="line">    while (bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        while (flow = find(S, INF))</span><br><span class="line">            res += flow;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int flux = 0;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    S = 0, T = n + 1;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u, v, Max, Min;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;Min, &amp;Max);</span><br><span class="line">        add(u, v, Max, Min);</span><br><span class="line">        in[v] += Min, out[u] += Min;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // cout &lt;&lt; in[i] - out[i] &lt;&lt; endl;</span><br><span class="line">        if (in[i] - out[i] &gt; 0)</span><br><span class="line">            add(S, i, in[i] - out[i], 0), flux += in[i] - out[i];</span><br><span class="line">        else</span><br><span class="line">            add(i, T, out[i] - in[i], 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (flux == dinic())</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;YES\n&quot;);</span><br><span class="line">        for (int i = 0; i &lt; (m &lt;&lt; 1); i += 2)</span><br><span class="line">            printf(&quot;%d\n&quot;, cpt[i ^ 1] + cm[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;NO&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>妈的太多了写不完了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/01/%E7%BD%91%E7%BB%9C%E6%B5%81/">http://example.com/2024/10/01/%E7%BD%91%E7%BB%9C%E6%B5%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/01/%E9%A2%98%E8%A7%A3P4056%20%5BJSOI2009%5D%E7%81%AB%E6%98%9F%E8%97%8F%E5%AE%9D%E5%9B%BE/" title="题解P4056 [JSOI2009]火星藏宝图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">题解P4056 [JSOI2009]火星藏宝图</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/01/%E9%A2%98%E8%A7%A3P4567%20%5BAHOI2006%5D%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/" title="题解P4567 [AHOI2006]文本编辑器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">题解P4567 [AHOI2006]文本编辑器</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">99</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/01/GJK%E7%AE%97%E6%B3%95/" title="GJK算法">GJK算法</a><time datetime="2024-10-01T02:53:38.485Z" title="Created 2024-10-01 10:53:38">2024-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/01/%E8%99%9A%E6%A0%91DP/" title="虚树DP">虚树DP</a><time datetime="2024-10-01T02:53:38.484Z" title="Created 2024-10-01 10:53:38">2024-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/01/%E9%A2%98%E8%A7%A3%20%E5%B9%B3%E6%96%B9%E5%92%8C/" title="题解 平方和">题解 平方和</a><time datetime="2024-10-01T02:53:38.484Z" title="Created 2024-10-01 10:53:38">2024-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/01/%E5%85%B3%E4%BA%8Epb_ds%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8/" title="关于pb_ds库的一些使用">关于pb_ds库的一些使用</a><time datetime="2024-10-01T02:53:38.483Z" title="Created 2024-10-01 10:53:38">2024-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/01/%E9%A2%98%E8%A7%A3%5BSCOI2009%5D%E6%9C%80%E9%95%BF%E8%B7%9D%E7%A6%BB/" title="题解[SCOI2009]最长距离">题解[SCOI2009]最长距离</a><time datetime="2024-10-01T02:53:38.483Z" title="Created 2024-10-01 10:53:38">2024-10-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>